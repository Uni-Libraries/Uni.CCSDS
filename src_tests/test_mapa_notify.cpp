/**
 * @file test_mapa_notify.cpp
 * @brief Tests for MAPA_Notify.indication (CCSDS 732.1-B-3 §3.5.3.3)
 *
 * Validates:
 *  - QUEUED notification on successful MAPA.request (uni_uslp_send_mapa)
 *  - SENT notification after successful frame build
 *  - REJECTED_INVALID on invalid parameters (e.g., zero-length or NULL)
 *
 * Notes:
 *  - Minimal path uses Rule '111' (No Segmentation) with variable-/fixed-length frames.
 *  - No REJECTED_UNSUPPORTED case is currently generated by MAPA in this implementation.
 *
 * © 2025 Uni-Libraries contributors — MIT License
 */

#include <catch2/catch_test_macros.hpp>

// uni.CCSDS
#include "uni_ccsds_uslp.h"
#include "uni_ccsds_uslp_internal.h"

#include <vector>
#include <cstdint>
#include <cstring>

namespace {

struct MapaEvent {
    uint8_t vcid{};
    uint8_t map{};
    uni_uslp_mapa_notify_type_t type{};
};

struct MapaCap {
    std::vector<MapaEvent> events;
};

void mapa_notify_cb(uni_uslp_context_t* ctx,
                    uint8_t vcid,
                    uint8_t map_id,
                    uni_uslp_mapa_notify_type_t nt,
                    void* user)
{
    (void)ctx;
    auto* cap = static_cast<MapaCap*>(user);
    cap->events.push_back(MapaEvent{vcid, map_id, nt});
}

} // namespace

TEST_CASE("MAPA_Notify: QUEUED then SENT", "[uslp][mapa][notify]")
{
    // Variable-length VC
    uni_uslp_managed_params_t p{};
    p.max_frame_length = 4096;
    p.min_frame_length = 0; // variable-length
    p.fecf_capability = false;
    p.vcf_seq_count_len_octets = 1; // exercise VCF update
    p.vcf_exp_count_len_octets = 0;

    uni_uslp_context_t ctx{};
    REQUIRE(uni_ccsds_uslp_init(&ctx, 0x4141, &p) == UNI_USLP_SUCCESS);

    const uint8_t VCID = 5;
    const uint8_t MAP  = 2;
    REQUIRE(uni_ccsds_uslp_configure_vc(&ctx, VCID, &p) == UNI_USLP_SUCCESS);
    REQUIRE(uni_ccsds_uslp_configure_map(&ctx, VCID, MAP, UNI_USLP_SERVICE_MAPA, &p) == UNI_USLP_SUCCESS);

    MapaCap cap{};
    REQUIRE(uni_ccsds_uslp_register_mapa_notify_callback(&ctx, VCID, MAP, mapa_notify_cb, &cap) == UNI_USLP_SUCCESS);

    // Send a MAPA SDU
    const uint8_t sdu[] = {0xDE, 0xAD, 0xBE, 0xEF};
    REQUIRE(uni_ccsds_uslp_send_mapa(&ctx, VCID, MAP, sdu, sizeof(sdu)) == UNI_USLP_SUCCESS);

    // Expect immediate QUEUED
    REQUIRE(cap.events.size() == 1);
    CHECK(cap.events[0].vcid == VCID);
    CHECK(cap.events[0].map == MAP);
    CHECK(cap.events[0].type == UNI_USLP_MAPA_NOTIFY_QUEUED);

    // Build a frame => should emit SENT
    std::vector<uint8_t> frame(512, 0x00);
    size_t out_len = frame.size();
    REQUIRE(uni_ccsds_uslp_build_frame(&ctx, VCID, MAP, frame.data(), &out_len) == UNI_USLP_SUCCESS);
    frame.resize(out_len);

    REQUIRE(cap.events.size() == 2);
    CHECK(cap.events[1].vcid == VCID);
    CHECK(cap.events[1].map == MAP);
    CHECK(cap.events[1].type == UNI_USLP_MAPA_NOTIFY_SENT);
}

TEST_CASE("MAPA_Notify: REJECTED_INVALID on zero-length", "[uslp][mapa][notify][invalid]")
{
    // Variable-length setup
    uni_uslp_managed_params_t p{};
    p.max_frame_length = 1024;
    p.min_frame_length = 0;
    p.fecf_capability = false;

    uni_uslp_context_t ctx{};
    REQUIRE(uni_ccsds_uslp_init(&ctx, 0x4242, &p) == UNI_USLP_SUCCESS);

    const uint8_t VCID = 3;
    const uint8_t MAP  = 1;
    REQUIRE(uni_ccsds_uslp_configure_vc(&ctx, VCID, &p) == UNI_USLP_SUCCESS);
    REQUIRE(uni_ccsds_uslp_configure_map(&ctx, VCID, MAP, UNI_USLP_SERVICE_MAPA, &p) == UNI_USLP_SUCCESS);

    MapaCap cap{};
    REQUIRE(uni_ccsds_uslp_register_mapa_notify_callback(&ctx, VCID, MAP, mapa_notify_cb, &cap) == UNI_USLP_SUCCESS);

    // Zero-length invalid
    const uint8_t* sdu = nullptr;
    auto st = uni_ccsds_uslp_send_mapa(&ctx, VCID, MAP, sdu, 0);
    REQUIRE(st == UNI_USLP_ERROR_INVALID_PARAM);

    // Expect REJECTED_INVALID
    REQUIRE(cap.events.size() == 1);
    CHECK(cap.events[0].vcid == VCID);
    CHECK(cap.events[0].map == MAP);
    CHECK(cap.events[0].type == UNI_USLP_MAPA_NOTIFY_REJECTED_INVALID);
}